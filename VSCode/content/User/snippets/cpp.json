{
  "greedy recursive": {
    "prefix": "greedy recursive",
    "body": []
  },
  "DP recursive": {
    "prefix": "DP recursive",
    "body": [
      "int DP_func(vector<int>& memo, int index) {",
      "\tint res = 0;",
      "\tif(memo[index] != ${1:initial_value}) {",
      "\t\treturn memo[index];",
      "\t}",
      "\tvector<int> subproblem = search_subp(index);",
      "\tfor(vector<int>::iterator it = subproblem.begin(); it != subproblem.end(); it++) {",
      "\t\tif(*it < 0) {",
      "\t\t\t",
      "\t\t} else {",
      "\t\t\tres = aux(res, DP_func(memo, *it));",
      "\t\t}",
      "\t}",
      "\tmemo[index] = res;",
      "\treturn res;",
      "}",
      "",
      "// 求解问题图中的所有问题",
      "int DP_main() {",
      "\tvector<int> memo;",
      "\tint i;",
      "\tint size = this->label.size()",
      "\t${2:vector<int> the_subp;}",
      "\tfor(i = 0; i <= size; i++) {",
      "\t\tmemo.push_back(${1:initial_value});",
      "\t}",
      "\tthis.label.push_back(${});",
      "\tDP_func(memo, size);",
      "\treturn memo[size];",
      "}"
    ],
    "description": "仅在 snippet:problem graph 中使用"
  },
  "topological sort": {
    "prefix": "topological sort",
    "body": [
      "void topological_sort(std::vector<int> adj[], int V) {",
      "\t// 创建一个数组来存储所有顶点的入度",
      "\tstd::vector<int> in_degree(V, 0);",
      "",
      "\t// 初始化入度",
      "\tfor (int u = 0; u < V; u++) {",
      "\t\tfor (int v : adj[u])",
      "\t\t\tin_degree[v]++;",
      "\t}",
      "",
      "\t// 创建一个队列并将所有入度为0的顶点加入队列",
      "\tstd::queue<int> q;",
      "\tfor (int i = 0; i < V; i++)",
      "\t\tif (in_degree[i] == 0)",
      "\t\t\tq.push(i);",
      "",
      "\t// 初始化计数器",
      "\tint cnt = 0;",
      "",
      "\t// 创建一个向量来存储拓扑排序的结果",
      "\tstd::vector<int> top_order;",
      "",
      "\t// 一次从队列中取出一个顶点",
      "\twhile (!q.empty()) {",
      "\t\t// 从队列中取出一个顶点",
      "\t\tint u = q.front();",
      "\t\tq.pop();",
      "\t\ttop_order.push_back(u);",
      "",
      "\t\t// 遍历所有的邻接顶点",
      "\t\tfor (int v : adj[u])",
      "\t\t\tif (--in_degree[v] == 0)",
      "\t\t\t\tq.push(v);",
      "",
      "\t\tcnt++;",
      "\t}",
      "",
      "\t// 检查是否有循环",
      "\tif (cnt != V) {",
      "\t\tstd::cout << \"存在循环，无法进行拓扑排序\\n\";",
      "\t\treturn;",
      "\t}",
      "",
      "\t// 打印拓扑排序的结果",
      "\tfor (int i : top_order)",
      "\t\tstd::cout << i << \" \";",
      "\tstd::cout << '\\n';",
      "}"
    ]
  },
  "sort": {
    "prefix": "sort",
    "body": [
      "void sort() {",
      "",
      "}",
      ""
    ]
  },
  "greedy iterate": {
    "prefix": "greedy interate",
    "body": []
  },
  "DP iterate": {
    "prefix": "DP interate",
    "body": [
      "struct Label",
      "{",
      "}",
      "",
      "struct node",
      "{",
      "\tLabel label;",
      "\tint index;",
      "\tint value;",
      "};",
      "",
      "int memo[N+1];",
      "memo[0] = 0;",
      "for(index_problem = 1; index_problem <= n; index_problem++) {",
      "\tres = ${1:initial_value};",
      "\t${2:Traversing and comparing the solutions of all sub-problems.}",
      "\tmemo[index_problem] = res;",
      "}"
    ]
  },
  "problem class": {
    "prefix": "problem class",
    "body": [
      "#include<vector>",
      "#include<tuple>",
      "",
      "using namespace std;",
      "",
      "class ${1:problem_class} {",
      "    vector<tuple<${2:int}>> label;",
      "    vector<int> value;",
      "    ${vector<int> sub_p;}",
      "",
      "    // 得到包含子问题索引的向量",
      "    inline vector<int> search_subp(int index) {",
      "        ${3:return;}",
      "    }",
      "",
      "    // 由该问题的子问题的解逐步得到该问题的解",
      "    inline int aux(int res, int temp) {",
      "        ${4:return;}",
      "    }",
      "",
      "    ${5:Dg}",
      "",
      "}"
    ]
  },
  "iterator": {
    "prefix": "iterator",
    "body": [
      "for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {",
      "    *it;",
      "}",
      ""
    ]
  }
}